Принцип инверсии зависимостей гласит: Модуль высокого уровня не должен зависеть от модулей низкого уровня. И то, и другое должно зависеть от абстракций. 

Абстракции не должны зависеть от деталей реализации. Детали реализации должны зависеть от абстракций. 
Если ваш код уже реализует принципы открытости/закрытости и подстановки Лисков, он уже будет неявно согласован с принципом инверсии зависимостей.  
Следуя принципу открытости/закрытости, вы создаете интерфейсы, которые можно использовать для предоставления различных высокоуровневых реализаций. 
Следуя принципу подстановки Лисков, вы гарантируете, что сможете заменить экземпляры класса низкого уровня объектами класса высокого уровня без какого-либо негативного воздействия на приложение. 
Таким образом, следуя этим двум принципам, вы гарантируете, что ваши классы высокого уровня и классы низкого уровня зависят от интерфейсов. Следовательно, вы неявно следуете принципу инверсии зависимостей.
У нас есть класс Student, который мы используем для создания экземпляров Student и класса TeamMemberships, который содержатся сведения о принадлежности учеников к разным командам.
Теперь мы определим высокоуровневый класс Analysis, где нам нужно отсеять всех учеников, принадлежащих красной команде.

Как видно из примера в комментарии, мы напрямую используем team_student_memberships.team_memberships в высокоуровневом классе Analysis, и мы используем реализацию этого списка непосредственно в классе высокого уровня. 
На данный момент все нормально, но представьте ситуацию, в которой нам нужно изменить эту реализацию со списка на что-то другое. В этом случае наш класс высокого уровня Analysis сломается, поскольку он зависит от деталей реализации TeamMemberships низкого уровня.
Теперь взгляните на сам пример, в котором мы меняем эту реализацию и приводим ее в соответствие с принципом инверсии зависимостей.

Чтобы следовать принципу инверсии зависимостей, нам необходимо убедиться, что класс высокого уровня Analysis не зависит от конкретной реализации класса низкого уровня TeamMembership. Вместо этого он должен зависеть от некоторой абстракции.
Итак, мы создаем интерфейс TeamMembershipLookup, который содержит абстрактный метод find_all_students_of_team, передающийся любому классу, наследующему этот интерфейс. 
Мы наследуем наш класс TeamMembership от этого интерфейса, следовательно, теперь класс TeamMembership должен предоставлять реализацию функции find_all_students_of_team. 
Затем эта функция передает результаты любому другому вызывающему ее объекту. Мы перенесли обработку, которая делалась в классе высокого уровня Analysis в TeamMemberships через интерфейс TeamMembershipLookup.
Сделав все это, мы убрали зависимость класса Analysis от класса TeamMemberships и перенесли ее в интерфейс TeamMembershipLookup. 
Теперь класс высокого уровня не зависит от деталей реализации класса низкого уровня. Любые изменения в деталях реализации класса низкого уровня не влияют на класс высокого уровня.
